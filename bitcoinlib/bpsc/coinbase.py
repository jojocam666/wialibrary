#Pseudo code of coinbase management and configuration in order to reward the mining contract and the nodes compared to their contribution to the informations relay on the network
#
#coinbase = []
#if new_block() = 1
#self.next_block = block
#self.next_block[coinbase = self.coinbase
#coinbase = Transaction(sender = "0", recipient = [bpsc, best_nodes#//define a method in the coinbase class to determine which node is called best in the mining process//,amount = coinbase_value)


# def update req_time():
#req_time = 0#//the time to spend before updating the cbs value
    
#import time
#start = time.time()
#new_block()
#end = time.time(new_block)
#print(end - start)
#if req_time = #//1 year:
#req_time = req_time * 2
#ti = ti + req_time
#return a
#return req_time

#def update_coinbase_value():
#  coinbase_value = 1000.000000000000000000000000
#  import update_req_time as urt
#  if urt.a =+:
#    coinbase_value = coinbase_value/1.61
#   return coinbase_value
#
#def divide_coinbase(): #//in order to determine the amount of the rewarding of the best nodes in the blockchain at the last block,excepting the mining contract
#if node.mining_state = "best": #//the state of the node concerning the mining of the previous_block or last_block
#   node.rewarding = True
#   node.reward = self.reward(relay_deposit,relays_n,relay_speed)#// the relay deposit is the amount deposit on the "deposit smart contract" in order to prioritize the nodes in the rewarding process; by default instancied at 0.00000
#   return True
#if node.status = "masternode":
#   node.reward = self.masterreward(master_deposit,relays_n,relay_speed)"
#   return True

#//the reward and masterreward methods are taken from the reward class,as well as the node state(mining_state,standby_state,chain_updating_state,etc) and status defining(normal node or masternode) 
#directory: node/state/status/reward/activity(banned or not)/relay(concerning the bipms)/deposit
#
